# vim: set ft=zsh

# Jump to the project's root
# A project is defined as containing markers of a project e.g. go.mod, composer.json, package.json, Makefile, .git/, etc.
# This can be configured via the JUMP_TO_PROJECT_ROOT_FIND_MARKERS=(...) list.
# If already in a project root, pierce through it to the next nearest parent project.
# Authors:
#   Bez Hermoso (c) 2024
#
if [[ -z $JUMP_TO_PROJECT_ROOT_FIND_MARKERS ]]; then
  export JUMP_TO_PROJECT_ROOT_FIND_MARKERS=(
    ".git"
    "Makefile"
    "go.mod"
    "main.go"
    "composer.json"
    "package.json"
    "Cargo.toml"
    ".env"
    "Gemfile"
    "Dockerfile"
    "docker-compose.y*ml"
    "README.md"
  )
fi

function _is-a-project-root {
  pathname="$@"

  if [[ $pathname == "/" ]]; then
    return 0
  fi


  if [[ ! -d $pathname ]]; then
    >&2 echo "Not a directory: $pathname"
    return 1
  fi

  declare -a name_predicates
  name_predicates+=("-name" $JUMP_TO_PROJECT_ROOT_FIND_MARKERS[1])
  for pattern in ${JUMP_TO_PROJECT_ROOT_FIND_MARKERS[@]:1}; do name_predicates+=("-o" "-name" "$pattern")
  done

  if { find $pathname -maxdepth 1 ${name_predicates[@]} -print -quit | grep -q . }; then
    return 0
  fi
  return 1
}

current_path=$(pwd)

pathname=$(command realpath $current_path/..)

while ! _is-a-project-root "$pathname"; do
  pathname=$(command realpath $pathname/..)
done

if [[ $current_path == $pathname ]] || [[ $pathname == "/" ]]; then
  if _is-a-project-root $current_path; then
    echo "Already at project root & it doesn't belong in another project"
  else
  echo "Current directory does not belong in a project"
  fi
fi

if (( $+commands[pushd] )); then
  pushd $pathname
else
  OLDPWD=$current_path
  cd $pathname
fi

return 0

